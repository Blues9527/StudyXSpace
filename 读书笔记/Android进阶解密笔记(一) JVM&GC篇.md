### 1.Java内存模型
1.线程共享：方法区和Java堆

2.线程私有：Java虚拟机栈、本地方法栈和程序计数器


```
Java堆：存放Java对象实例 和数组

方法区：存放运行时常量池、字段和方法信息、静态变量等

Java栈：存放Java方法调用的状态，包括局部变量，参数，返回值及运算的中间结果
```
![jvm.png](http://note.youdao.com/yws/res/15643/WEBRESOURCE8a5ce8ba9b91ddf901ee19e38d15e26c)


### 2.Java GC相关
1.GC算法：分代收集法，主要分为新生代和老年代，新生代继续划分为：Eden、From Survivor、To Survivor

2.垃圾标记算法：引用计数法和根搜索法。

```
引用计数法：
工作原理：当对象在某处被引用的时候，引用计数器+1，引用失效的时候就-1.当引用计数器的值变为0的时候，则变成了垃圾。

缺点：无法解决对象间相互循环引用的问题。

根搜索法（可达性分析法）：
工作原理：选定一些对象作为GCRoots，组成对象集合，然后以GCRoots作为起始点向下搜索，如果目标对象到GCRoots是连接着的，则称目标对象是可达的，如果目标对象不可达则说明对象是可以被回收的。

可选取为GCRoots对象的条件：
1.Java栈中引用的对象
2.本地方法栈中JNI引用的对象
3.方法区中运行时常量池引用的对象
4.方法区中静态属性引用的对象
5.运行中的线程
6.由引导类加载器加载的对象
7.GC控制的对象
```


3.Java中的四种引用方式：强引用、弱引用、软引用和虚拟引用

```
区别：
强引用：只要对象存在引用关系，则无法被回收。即使抛出OOM也不会进行回收对象。

弱引用（WeakReference）：GC时无论内存是否充足都会被回收

软引用（SoftReference）：当内存不足的时候被回收，如果回收后内存依旧不足，则抛出OOM

虚拟引用（PhantomReference）：随时都会被回收，被回收时会收到一个系统的通知。
```

4.垃圾回收算法：标记-清除法、复制算法、标记-压缩算法、分代收集算法

##### 标记-清除法：
==工作原理：== 分为两个阶段，分别是标记和清除。标记则是标记处可以回收的对象，清除就是回收被标记的对象所占的空间。

==缺点：== 一、标记和清除效率不高；二、会产生大量不连续的内存碎片，导致后续没有连续内存分配给较大的对象从而提前出发新的垃圾回收行为。

##### 复制算法：
==工作原理：== 把内存划分为两块相等的区域，每次只使用其中一个区域。在垃圾收集的时候，遍历当前使用的区域，把存活的对象复制到另外一个区域中，最后对当前使用的区域的可回收对象进行回收

==缺点：== 内存为原来的一般，对对象数量较少的时候效率较高。广泛用于新生代中。

##### 标记-压缩算法：
==工作原理：== 老年代对象存活率高，不适用于复制算法，效率过低。在标记可回收对象后将所有存活的对象压缩到内存的一端，是内存紧凑地连在一起，对边界以外的内存进行回收。

##### 分代收集法：
==工作原理：== 应对不同的对象采用不同的收集策略，根据生命周期长短将对象放在不同区域，对不同区域采用不同收集算法。

分代收集分为两种类型：MinorCollection即新生代收集 和 FullCollection（MajorCollection）即老年代收集，FullCollection通常会伴随至少一次的MinorCollection，收集频率低且耗时长。

当执行MinorCollection时，Eden存活的对象会被复制到To Survivor，并且之前经历过一次MinorCollection并在From Survivor中存活的对象也会复制到To Survivor。那么Eden和FromSurvivor剩下的对象都是可回收的对象。存在两种情况Eden对象和From Survivor 对象不复制到 To Survivor而晋升到老年代，分别是：
一、存活时间超过-XX：MaxTenuringThreshold所指定的阙值；二、当To Survivor容量达到阙值。


5.Java对象在虚拟机中的生命周期：

```
七个阶段：
1.创建阶段（Created）

    1.1 为对象分配内存空间
    1.2 构建对象
    1.3 从超类到子类对static成员进行初始化
    1.4 递归调用超类的构造方法
    1.5 调用子类的构造方法

2.应用阶段（In Use）
    当对象被创建并分配给变量赋值时，就切换成应用状态，其中一定要有被引用，无论是强引用，还是显示地使用软引用、弱引用或者是虚引用。

3.不可见阶段（Invisible）
    在程序中找不到对象的任何强引用，或者程序执行已经超出了对象的作用域。处于该阶段时，对象仍可能被特殊的强引用GCRoots持有着，如本地方法 栈中JNI对象或者被运行中的线程引用着等。

4.不可达阶段（Unreachable）
    在程序中找不到任何强引用，并且垃圾回收器发现对象不可达。

5.收集阶段（Collected）
    垃圾回收器发现对象不可达，已经准备重新分配内存空间，如果对象重写了finalize方法，则会调用该方法，
    
6.终结阶段（Finalized）
    对象执行完finalize方法后仍处于不可达状态或者对象没有重写finalize方法，则对象进入终结阶段等待垃圾回收器对该对象空间进行回收。

7.对象空间重新分配阶段（Deallocated）
    当垃圾回收器对对象的内存重新重新分配或者回收时，这个对象就会彻底消失。
```
